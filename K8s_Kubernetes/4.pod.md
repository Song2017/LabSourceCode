## Kubenetes作业管理
### 为什么我们需要 Pod
#### 1. 处理容器之间的运维关系
容器的本质是进程, 不能很好的处理容器间的紧密协作, 单容器的工作方式，就难以描述真实世界里复杂的应用架构
比如, 互相之间会发生直接的文件交换、
使用 localhost 或者 Socket 文件进行本地通信、
会发生非常频繁的远程调用、
需要共享某些 Linux Namespace(Network Namespace)
云计算系统的操作系统是 k8s ，容器就相当于是其进程，而 Pod 则是进程组
`Pod，实际上是在扮演传统基础设施里“虚拟机”的角色；而容器，则是这个虚拟机里运行的用户程序。`
#### 2. 容器设计模式
##### Pod 的实现原理
`关于 Pod 最重要的一个事实是：它只是一个逻辑概念`
Pod 里的所有容器，共享的是同一个 Network Namespace，并且可以声明共享同一个 Volume
1. 在 Kubernetes 项目里，Pod 的实现需要使用一个中间容器，这个容器叫作 Infra 容器。
在这个 Pod 中，Infra 容器永远都是第一个被创建的容器，
而其他用户定义的容器，则通过 Join Network Namespace 的方式，与 Infra 容器关联在一起
2. 在 Pod 中，所有 Init Container 定义的容器，都会比 spec.containers 定义的用户容器先启动。
并且，Init Container 容器会按顺序逐一启动，而直到它们都启动并且退出了，用户容器才会启动
##### sidecar模式
sidecar 指的就是我们可以在一个 Pod 中，启动一个辅助容器，来完成一些独立于主进程（主容器）之外的工作
容器的日志收集
#### 传统应用架构如何过渡到微服务架构
`Pod，是 Kubernetes 项目的原子调度单位, Pod，而不是容器，才是 Kubernetes 项目中的最小编排单位`
把整个虚拟机想象成为一个 Pod，把这些进程分别做成容器镜像，把有顺序关系的容器，定义为 Init Container。
这才是更加合理的、松耦合的容器编排诀窍，也是从传统应用架构，到“微服务架构”最自然的过渡方式